/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package code_contest;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Main2 {

	public static final String ARTICLE = "./data/article.txt";

	public static void main(String args[]) {
		PrintWriter writer = new PrintWriter(System.out);
		System.out.println("★★★★★start");
		long start = System.currentTimeMillis();
		System.out.println("init start");
		WordController2 wordController = new WordController2();
		wordController.init();
		long endInit = System.currentTimeMillis();
		System.out.println("init : elapsed time: " + ((endInit - start) / 1000.0) + "[sec]");

		System.out.println("execute start");
		long startExe = System.currentTimeMillis();
		articleFileRead(wordController);
		long endExe = System.currentTimeMillis();
		System.out.println("execute : elapsed time: " + ((endExe - startExe) / 1000.0) + "[sec]");

		long startOut = System.currentTimeMillis();
		wordController.outputResult(writer);
		long endOut = System.currentTimeMillis();
		System.out.println("execute : elapsed time: " + ((endOut - startOut) / 1000.0) + "[sec]");

		long end = System.currentTimeMillis();
		System.out.println("★★★★★total : elapsed time: " + ((end - start) / 1000.0) + "[sec]");
	}

	/**
	 * articleファイルの読み込みと文字列の一致判定
	 */
	public static void articleFileRead(WordController2 wordController) {
		Path file = Paths.get(ARTICLE);
		try (FileChannel fc = FileChannel.open(file)) { // FileChannelを生成
			ByteBuffer buf = ByteBuffer.allocate(1024 * 1024 * 100); // 100メガバイト分のバッファを確保
			while (true) {
				// バッファのposition/limitをリセット
				buf.clear();
				// バッファにファイルからのデータを読み込む
				if (fc.read(buf) == -1) {
					break;
				}
				// positionとlimitを入れ替え
				buf.flip();

				// バッファ内の内容を全て、順に一致判定処理を行う
				while (buf.hasRemaining()) {
					wordController.set((char) buf.get());
				}
			}
			wordController.lastDo();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

/**
 * 評価対象となる文字全てを管理するクラス
 * 
 * @author tatsuya kozu
 *
 */
class WordController2 {
	private List<Word2> wordList;
	public List<Character> checkWord = new ArrayList<>(10000);

	public void init() {
		try {
			this.wordList = Files.lines(Paths.get("./data/words.txt"), StandardCharsets.UTF_8).map(str -> new Word2(str))
					.collect(Collectors.toList());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void outputResult(PrintWriter writer) {
		long sum = 0;
		for (Word2 w : wordList) {
			long count = w.getCount();
			sum = sum + count ;
			writer.print(count);
			System.out.println(count);
		}
		System.out.println(sum);
	}

	public void set(char c) {
		if (c == '\n') {
			doCheck();
		} else {
			this.checkWord.add(c);
		}
	}

	public void lastDo() {
		if (!this.checkWord.isEmpty()) {
			this.doCheck();
		}
	}

	private void doCheck() {
		if (this.checkWord.isEmpty()) {
			return;
		}
//		this.wordList.stream().forEach(w ->w.check(this));
		for (Word2 w : wordList) {
			w.check(this);
		}
		checkWord.clear();
	}
}

/**
 * 評価対象となる文字を格納、処理するクラス
 * 
 * @author tatsuya kozu
 *
 */
class Word2 {
	private char[] word;
	private int duplicate = 1;
	private long count = 0;

	public Word2(String str) {
		this.word = str.toCharArray();
	}

	public void check(WordController2 wordController) {
		int wordCount = wordController.checkWord.size();
		if (word.length > wordCount) {
			return;
		}
		int firstIndex = 0;
//		int firstIndex = wordController.checkWord.indexOf(word[0]);
		if (firstIndex < 0) {
			return;
		}
		for (int i = firstIndex;; i++) {
			if (i + word.length > wordCount) {
				break;
			}
			int index = i;
			for (char c : word) {
				if (c != wordController.checkWord.get(index)) {
					break;
				}
				index++;
			}
			if (index - firstIndex == word.length) {
				count++;
			}
		}
	}

	public long getCount() {
		return this.count;
	}
}