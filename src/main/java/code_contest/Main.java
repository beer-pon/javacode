/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package code_contest;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import it.unimi.dsi.fastutil.chars.Char2ObjectMap;
import it.unimi.dsi.fastutil.chars.Char2ObjectOpenHashMap;

public class Main {

	public static final String ARTICLE = "./data/article.txt";

	public static void main(String args[]) {
		System.out.println("★★★★★start");
		long start = System.currentTimeMillis();
		System.out.println("init start");
		WordController wordController = new WordController();
		wordController.init();
		long endInit = System.currentTimeMillis();
		System.out.println("init : elapsed time: " + ((endInit - start) / 1000.0) + "[sec]");

		System.out.println("execute start");
		long startExe = System.currentTimeMillis();
		articleFileRead(wordController);
		long endExe = System.currentTimeMillis();
		System.out.println("execute : elapsed time: " + ((endExe - startExe) / 1000.0) + "[sec]");

		long startOut = System.currentTimeMillis();
		wordController.outputResult();
		long endOut = System.currentTimeMillis();
		System.out.println("execute : elapsed time: " + ((endOut - startOut) / 1000.0) + "[sec]");

		long end = System.currentTimeMillis();
		System.out.println("★★★★★total : elapsed time: " + ((end - start) / 1000.0) + "[sec]");
	}

	/**
	 * articleファイルの読み込みと文字列の一致判定
	 */
	public static void articleFileRead(WordController wordController) {
		Path file = Paths.get(ARTICLE);
		try (FileChannel fc = FileChannel.open(file)) { // FileChannelを生成
			ByteBuffer buf = ByteBuffer.allocateDirect(1024 * 1024 * 1024 + 10); // 100メガバイト分のバッファを確保
			while (true) {
				// バッファのposition/limitをリセット
				buf.clear();
				// バッファにファイルからのデータを読み込む
				if (fc.read(buf) == -1) {
					break;
				}
				// positionとlimitを入れ替え
				buf.flip();

				// バッファ内の内容を全て、順に一致判定処理を行う
				while (buf.hasRemaining()) {
					char firstChar = (char) buf.get();
					// 処理対象のpositionを記録
					buf.mark();
					int wordCount = wordController.getMatchWordSize(firstChar);
					if(wordCount == 0) continue;
					char[] checkWord = new char[wordCount];
					checkWord[0] = firstChar;
					for(int i = 1 ; wordCount > i ; i++) {
						if(!buf.hasRemaining()) break;
						checkWord[i] = (char) buf.get();
					}
					wordController.doCheck(checkWord);
					// 判定処理用に進めた分のpositionを戻す
					buf.reset();
				}
			}
 		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

/**
 * 評価対象となる文字全てを管理するクラス
 * 
 * @author tatsuya kozu
 *
 */
class WordController {
	public Char2ObjectMap<WordBlock> wordMap = new Char2ObjectOpenHashMap<>(1000);
//	public HashMap<Character, WordBlock> wordMap = new HashMap<Character, WordBlock>(1000);

	public void init() {
		try {
			Files.lines(Paths.get("./data/words.txt"), StandardCharsets.UTF_8).forEach(str -> this.setMap(str));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void doCheck(char[] checkWord) {
 		for(Word w :this.wordMap.get(checkWord[0]).getWordList()) {
			w.check(checkWord);
		}
		
	}

	public int getMatchWordSize(char key) {
		if(!wordMap.containsKey(key)) {
			return 0;
		}
		return wordMap.get(key).maxLength;
	}

	private void setMap(String str) {
		if (str.isEmpty())
			return;
		char key = str.toCharArray()[0];
		WordBlock block = wordMap.get(key);
		if (block == null) {
			block = new WordBlock();
			block.addList(str);
			wordMap.put(key, block);
		} else {
			block.addList(str);
		}
	}

	public void outputResult() {
		long sum = 0;
		for (WordBlock block : wordMap.values()) {
			for(Word w :block.getWordList()) {
				long count = w.getCount();
				sum = sum + count;
//				System.out.println(count);
			}
		}
		System.out.println(sum);
	}
}

/**
 * 先頭文字が同じwordlistのセット
 * 
 * @author tatsuya kozu
 *
 */
class WordBlock {
	public int maxLength = 0;
	private List<Word> wordList = new ArrayList<>();

	public void addList(String str) {
		if (maxLength < str.length()) {
			maxLength = str.length();
		}
		wordList.add(new Word(str));
	}
	
	public List<Word> getWordList(){
		return this.wordList;
	}
}

/**
 * 評価対象となる文字を格納、処理するクラス
 * 
 * @author tatsuya kozu
 *
 */
class Word {
	private char[] word;
	private long count = 0;

	public Word(String str) {
		this.word = str.toCharArray();
	}

	public void check(char[] checkWord) {
		if(word.length > checkWord.length) return ;
		for(int i = 0 ; word.length > i ; i++) {
			if(word[i] != checkWord[i]) return;
		}
		count++ ;
	}

	public long getCount() {
		return this.count;
	}
}